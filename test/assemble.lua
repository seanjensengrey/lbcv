--[[ Copyright (c) 2010 Peter Cawley

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. ]]

--[[ Utility module for crafting Lua 5.2 bytecode which cannot be generated by
the default code generator. This is done in the form of a crude line-based
assembler, which takes plaintext with at most one virtual machine instruction
or assembler directive per line, and outputs a reader function which returns
successive chunks of bytecode.

Exports a single function called "assemble".

]]

-- Create lookup-table for opcode names to codes
local opcode_name_to_code = {}
for code, name in pairs{[0] = "MOVE", "LOADK", "LOADBOOL", "LOADNIL",
  "GETUPVAL", "GETTABUP", "GETTABLE", "SETTABUP", "SETUPVAL", "SETTABLE",
  "NEWTABLE", "SELF", "ADD", "SUB", "MUL", "DIV", "MOD", "POW", "UNM", "NOT",
  "LEN", "CONCAT", "JMP", "EQ", "LT", "LE", "TEST", "TESTSET", "CALL",
  "TAILCALL", "RETURN", "FORLOOP", "FORPREP", "TFORCALL", "TFORLOOP",
  "SETLIST", "CLOSE", "CLOSURE", "VARARG", "EXTRAARG"}
do
  opcode_name_to_code[name] = code
end

-- Lookup table for opcode modes ("ABC" mode is assumed if not listed)
local opcode_modes = {LOADK = "ABx", JMP = "AsBx", FORLOOP = "AsBx",
  FORPREP = "AsBx", TFORLOOP = "AsBx", CLOSURE = "ABx", EXTRAARG = "Ax"}

-- Convert an unsigned integer number into a string of length 4 whose bytes
-- represent the number in little endian format.
local function ub4(n)
  local b0 = n % 0x100
  n = (n - b0) / 0x100
  local b1 = n % 0x100
  n = (n - b1) / 0x100
  local b2 = n % 0x100
  n = (n - b2) / 0x100
  local b3 = n % 0x100
  n = (n - b3) / 0x100
  return string.char(b0, b1, b2, b3)
end

--[[ Assemble plaintext into Lua 5.2 bytecode.

The format of accepted code is:
code ::= line {[\r\n]+ line}
line ::= directive | instruction
directive ::= .(constant|k) Name Expression |
              .(proto|prototype) Name |
              .vararg |
              .stack[size] Number |
              .(params|args) Number |
              .r[eg] Name Number |
              .up[value] Name
instruction ::= {label} opcode [operand] [operand] [operand]
label ::= Name:
opcode ::= move | loadk | loadbool  | ... | vararg | extraarg
operand ::= Name | Number

The assembler has a concept of the "current prototype", with instructions and
certain directives affecting the "current prototype". The current prototype
starts as the top-level chunk, and can be changed with the ".prototype"
directive.

The ".constant" directive (shortened to ".k") is used to give a name to a
specific value. The expression following the name is evaluated at compile-time
to obtain the value of the constant. The list of named constants lives outside
of each individual prototype, so constants can be used anywhere as long as they
are defined somewhere.

The ".prototype" directive (shortened to ".proto") is used to start a new
prototype. Subsequent prototype-specific directives will affect the new
prototype, and likewise instructions will be appended to the new prototype.
The name given in the directive can be used in "closure" instructions in other
prototypes to instantiate the prototype.

The ".vararg" directive marks the current prototype as accepting a variable
length argument list.

The ".stacksize" directive (shortened to ".stack") specifies the number of
registers which the current prototype needs. If the given number is N, then
registers 0 through N - 1 (inclusive) will be available for use.

The ".params" directive (shortened to ".args") specifies the number of fixed
arguments which the current prototype expects. If the given number is N, then
registers 0 through N - 1 (inclusive) will be initialised with the passed
arguments (or nil) when an instance of the prototype is called.

The ".reg" directive (shortened to ".r") assigns a name to a register for the
entirity of the current prototype, and ensures that the stack size is set high
enough for the register to exist.

The ".upvalue" directive (shortened to ".up") creates a new upvalue in the
current prototype, which refers to a register or upvalue of the enclosing
prototype with the same name. The specified name can then be used in any
instruction which expects an upvalue.

Labels are of the form "Name:", and assign a name to the next instruction. This
name can then be used anywhere in the current prototype to mean the offset
between the instruction it is used in, and the instruction it labels.

]]
local function assemble(code)
  ----- Parse text into structures -----
  local constants = {} -- Map of constant name to constant value
  local proto = { -- The current prototype
    code = {}, -- Array of instructions, each instruction being a table of form
               -- {op = N, a = N, b = N, c = N}, where N is a name or number.
    upvalues = {}, -- Array of upvalue names, and map of upvalue name to index
    labels = {}, -- Map of label name to absolute program counter position
    regs = {}, -- Map of register name to register index
  }
  local prototypes = {_main = proto} -- Map of prototype name to prototype
  local labels = {} -- The set of labels to be applied to the next instruction
  for line in code:gmatch"[^\r\n]+" do repeat
    -- Check if the line contains a directive, and handle it if it does
    local directive, extra = line:match"^%s*%.([a-zA-Z_]+)(.*)$"
    if directive then
      local ldirective = directive:lower()
      if ldirective == "constant" or ldirective == "k" then
        local name, extra = extra:match"^%s*([a-zA-Z_][a-zA-Z0-9_]*)(.*)$"
        constants[name or error("Expected name after " .. directive)] = assert(loadstring("return " .. extra), "Expected value after " .. directive .. " " .. name)()
      elseif ldirective == "proto" or ldirective == "prototype" then
        proto = {code = {}, upvalues = {}, labels = {}, regs = {}}
        prototypes[extra:match"[a-zA-Z_][a-zA-Z0-9_]*" or error("Expected name after " .. directive)] = proto
      elseif ldirective == "up" or ldirective == "upvalue" then
       local name = extra:match"[a-zA-Z_][a-zA-Z0-9_]*" or error("Expected name after " .. directive)
       proto.upvalues[name] = #proto.upvalues
       proto.upvalues[#proto.upvalues + 1] = name
      elseif ldirective == "vararg" then
        proto.vararg = true
      elseif ldirective == "stack" or ldirective == "stacksize" then
        proto.numregs = tonumber(extra) or error("Expected number after " .. directive)
      elseif ldirective == "params" or ldirective == "args" then
        proto.numparams = tonumber(extra) or error("Expected number after " .. directive)
      elseif ldirective == "reg" or ldirective == "r" then
        local name, extra = extra:match"^%s*([a-zA-Z_][a-zA-Z0-9_]*)(.*)$"
        proto.regs[name or error("Expected name after " .. directive)] = tonumber(extra) or error("Expected number after " .. directive)
        proto.numregs = math.max(proto.numregs or 0, tonumber(extra) + 1)
      else
        error("Unrecognised assembler directive: " .. directive)
      end
      break -- continue (to next line)
    end
    
    -- Strip any labels off the front of the line
    while true do
      local label, extra = line:match"^%s*([a-zA-Z_][a-zA-Z0-9_]*):(.*)$"
      if not label then
        break
      end
      labels[label] = true
      line = extra
    end
    
    -- Check if the line contains an instruction
    local op, a, b, c = line:match"([a-zA-Z_]+)%s*(%S*)%s*(%S*)%s*(%S*)"
    if op then
      local uop = op:upper()
      if not opcode_name_to_code[uop] then
        error("Unrecognised opcode: " .. op)
      end
      for label in pairs(labels) do
        proto.labels[label] = #proto.code
      end
      proto.code[#proto.code + 1] = {
        op = uop,
        a = tonumber(a) or a,
        b = tonumber(b) or b,
        c = tonumber(c) or c
      }
      if next(labels) then
        labels = {}
      end
    end
  until true end
  
  ----- Link (resolve names to numbers, populate constant tables, etc.) -----
  for name, proto in pairs(prototypes) do
    proto.prototypes = {}
    proto.constants = {}
    local usedprototypes = {}
    local usedconstants = {}
    for pc, ins in pairs(proto.code) do
      local op = ins.op
      for i, arg in pairs(ins) do
        if i ~= "op" and type(arg) ~= "number" then
          if proto.regs[arg] then
            arg = proto.regs[arg]
          elseif proto.labels[arg] then
            arg = proto.labels[arg] - pc
          elseif proto.upvalues[arg] then
            arg = proto.upvalues[arg]
          elseif prototypes[arg] then
            if not usedprototypes[arg] then
              usedprototypes[arg] = #proto.prototypes
              proto.prototypes[#proto.prototypes + 1] = prototypes[arg]
            end
            arg = usedprototypes[arg]
          elseif constants[arg] then
            if not usedconstants[arg] then
              usedconstants[arg] = #proto.constants
              proto.constants[#proto.constants + 1] = constants[arg]
            end
            arg = usedconstants[arg]
            if op == "LOADK" then
              -- LoadK offsets constant indicies by 1 to allow 0 to be used to
              -- mean "Use ExtraArg".
              arg = arg + 1
            elseif op ~= "EXTRAARG" then
              -- Constants elsewhere than LoadK and ExtraArg are only found in
              -- RK fields, so they need an offset to make them K rather than R
              arg = arg + 256
            end
          elseif arg == "" then
            -- Ommitted operands are treated as zero
            arg = 0
          else
            error("Unable to resolve symbol '" .. arg .. "'")
          end
          ins[i] = arg
        end
      end
    end
  end
  
  ----- Compile (spit out bytecode) -----
  local yield = coroutine.yield
  return coroutine.wrap(function()
    -- This header is slightly special, in that it is accepted by lbcv's decoder,
    -- but will never be accepted by an unmodified Lua 5.2, as it forces all
    -- numbers and strings to be zero bytes long.
    yield "\27Lua\x52\0\1\4\0\4\0\0\x19\x93\r\n\x1a\n"
    local function compile(proto, parent)
      yield(ub4(0):rep(2))
      yield(string.char(proto.numparams or 0, proto.vararg and 1 or 0, proto.numregs or 0))
      -- Instruction array
      yield(ub4(#proto.code))
      for _, ins in ipairs(proto.code) do
        local mode = opcode_modes[ins.op]
        local op = opcode_name_to_code[ins.op]
        local encoded = op + ins.a * 2^6
        if not mode then
          encoded = encoded + ins.c * 2^14 + ins.b * 2^23
        elseif mode == "AsBx" then
          encoded = encoded + (ins.b + 131071) * 2^14
        elseif mode == "ABx" then
          encoded = encoded + ins.b * 2^14
        elseif mode ~= "Ax" then
          error("Unknown encoding mode " .. mode)
        end
        yield(ub4(encoded))
      end
      -- Constant table (exlcuding prototypes)
      yield(ub4(#proto.constants))
      for _, k in ipairs(proto.constants) do
        local t = type(k)
        local encoded
        if t == "boolean" then
          encoded = k and "\1\1" or "\1\0"
        elseif t == "nil" then
          encoded = "\0"
        elseif t == "number" then
          encoded = "\3"
        elseif t == "string" then
          encoded = "\4"
        else
          error("Invalid constant type: " .. t)
        end
        yield(encoded)
      end
      -- Prototypes
      yield(ub4(#proto.prototypes))
      for _, p in ipairs(proto.prototypes) do
        compile(p, proto)
      end
      -- Upvalues
      yield(ub4(#proto.upvalues))
      for _, upvalue in ipairs(proto.upvalues) do
        if not parent then
          yield "\0\0"
        elseif parent.regs[upvalue] then
          yield(string.char(1, parent.regs[upvalue]))
        elseif parent.upvalues[upvalue] then
          yield(string.char(0, parent.upvalues[upvalue]))
        else
          error("Unresolved upvalue: " .. upvalue)
        end
      end
      -- Debug information
      yield(ub4(0):rep(3))
    end
    compile(prototypes._main, nil)
    while true do yield "" end
  end)
end

return {
  assemble = assemble
}
